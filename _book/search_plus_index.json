{"./":{"url":"./","title":"介绍","keywords":"","body":"目录 介绍 JAVASCRIPT常见函数 工具 日期 DOM操作 EVENT事件 正则表达式 算法-es6版 HTML与CSS CSS样式 CSS3动画 CSS设置居中的方案 开发工具 开发者工具 markdown语法 版本记录 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-05-04 16:52:49 "},"docs/chapter1/":{"url":"docs/chapter1/","title":"JAVASCRIPT常见函数","keywords":"","body":"JAVASCRIPT 此部分主要是javascript相关的代码，包括一些常用的工具函数，dom操作等 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:40:53 "},"docs/chapter1/工具.html":{"url":"docs/chapter1/工具.html","title":"工具","keywords":"","body":"工具 禁用按钮倒计时 /** * 禁用按钮倒计时 * @param {Object} element - DOM对象,按钮 * @param {Number} time - 倒计时时间，默认60秒 * @param {String} msg - 倒计时提示语 */ function showTimer(element, time, msg) { if (!arguments[1]) { time = 60; } if (!arguments[1]) { msg = \"重新发送\"; } var countdown = time; var eText = element.innerHTML; function timer() { if (countdown === 0) { element.removeAttribute(\"disabled\"); element.innerHTML = eText; countdown = time; return; } else { element.setAttribute(\"disabled\", true); element.innerHTML = msg + \"(\" + countdown + \")\"; countdown--; } setTimeout(function () { timer(); }, 1000); } timer(); } 判断是否为空 /** * 判断字符串是否为空 * @param {String} str - 字符串 * @returns {Boolean} */ function isNull (str) { if (str == null || str == '' || typeof(str) == \"undefined\") { return true; } else { return false; } } json格式转树状结构 /** * json格式转树状结构(最大支持三级) * @param {Object} json数据 * @param {String} id的字符串 * @param {String} 父id的字符串 * @param {Object} children的字符串 * @return {Array} 数组 */ function transData(a, idStr, pidStr, chindrenStr) { var r = [], tr = [], hash = {}, id = idStr, pid = pidStr, children = chindrenStr; for (i in a) { hash[a[i][id]] = a[i]; } for (j in a) { var aVal = a[j], hashVP = hash[aVal[pid]]; if (hashVP) { !hashVP[children] && (hashVP[children] = []); hashVP[children].push(aVal); } else { tr.push(aVal); } } for (k in tr) { tr[k][\"level\"] = 1; r.push(tr[k]); for (m in tr[k][children]) { tr[k][children][m][\"level\"] = 2; r.push(tr[k][children][m]); for (n in tr[k][children][m][children]) { tr[k][children][m][children][n][\"level\"] = 3; r.push(tr[k][children][m][children][n]); for (i in tr[k][children][m][children][n][children]) { tr[k][children][m][children][n][children][i][\"level\"] = 4; r.push(tr[k][children][m][children][n][children][i]); } } } } return { treeDatas: tr, treeList: r }; } 获取地址栏参数 /** * 获取地址栏参数 * @param {String} name - 参数名 * @returns {String} 参数值 */ function getQueryString(name) { var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return decodeURI(r[2]); return null; } 获取运行环境 /** * 获取运行环境 * @returns */ var browserUtil = { versions: function () { var u = navigator.userAgent, app = navigator.appVersion; return { mobile: !!u.match(/AppleWebKit.*Mobile.*/), // 是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), // ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Adr') > -1 // android终端 }; }(), isWeiXin: function () { var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == \"micromessenger\") { // 在微信中打开 return true; } else { return false; } }(), isQQ: function () { var ua = navigator.userAgent.toLowerCase(); if (ua.match(/QQ/i) == \"qq\") { // 在QQ空间打开 return true; } else { return false; } }(), isWeiBo: function () { var ua = navigator.userAgent.toLowerCase(); if (ua.match(/WeiBo/i) == \"weibo\") { // 在新浪微博客户端打开 return true; } else { return false; } }(), language: (navigator.browserLanguage || navigator.language).toLowerCase() } token生成 /** * token生成 * @param {Number} len - token长度 * @returns {String} token */ function randomString (len) { len = len || 16; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (i = 0; i 手机号隐藏中间几位号码 /** * 手机号码隐藏中间四位 * @param {Number} phone - 手机号 * @returns {String} 处理后的手机号码 */ function formatPhone(phone){ if(phone) { var regPhone= /(\\d{4})\\d{4}(\\d{3})/; var phone= phone.replace(regPhone,\"$1****$2\"); return phone; }else { return null; } } 文字滚动 /** * @desc 文字滚动效果 * @param {Number} lineHieght - 文字一次向上滚动的距离或高度； * @param {Number} speed - 滚动速度； * @param {Number} delay - 滚动停顿的时间间隔； * @param {Number} elementTop - 文字内容顶端与滚动区域顶端的距离，初始值为0； * @param {Object} element - 文档对象； * startmarquee(25, 30, 3000, 0, 0, element);//带停顿效果 * startmarquee(25, 40, 0, 0, 0, element);//不间断连续 */ function startMarquee(lineHieght, speed, delay, elementTop, element) { //传递参数 var hander, flag = false; element.innerHTML += element.innerHTML; //对象中的实际内容被复制了一份，包含了两个ul，当然li标签也由原来的3行，变为6行；复制的目的在于给文字不间断向上滚动提供过渡。 element.onmouseover = function () { flag = true; } //鼠标滑过，停止滚动； element.onmouseout = function () { flag = false; } //鼠标离开，开始滚动；flag是true还是false直接影响到下面start()函数的执行； element.scrollTop = elementTop; //文字内容顶端与滚动区域顶端的距离，初始值为0； function start() { hander = setInterval(scrolling, speed); //每隔一段时间，setInterval便会执行一次scrolling函数；speed越大，滚动时间间隔越大，滚动速度越慢； if (!flag) { element.scrollTop += 1; } //滚动停止或开始，取决于flag传来的布尔值； } function scrolling() { if (element.scrollTop % lineHieght != 0) { //如果不被整除，即一次上移的高度达不到lineHieght，则内容会继续往上滚动； element.scrollTop += 1; if (element.scrollTop >= element.scrollHeight / 2) element.scrollTop = 0; //对象o中的内容之前被复制了一次，所以它的滚动高度，其实是原来内容的两倍高度；当内容向上滚动到scrollHeight / 2的高度时，全部3行文字已经显示了一遍，至此整块内容scrollTop归0；再等待下一轮的滚动，从而达到文字不间断向上滚动的效果； } else { clearInterval(hander); //否则清除hander，暂停滚动 setTimeout(start, delay); //经过delay间隔后，启动start()再连续滚动 } } setTimeout(start, delay); //第一次启动滚动；setTimeout会在一定的时间后执行函数start()，且只执行一次 } JS字符串转成小驼峰 操作字符串数组 function tranformStr1(str){ var strArr=str.split('-'); for(var i=1;i 操作字符数组 function tranformStr2(str){ var strArr=str.split(''); for(var i=1;i 利用正则表达式 function transformStr3(str){ var re=/-(\\w)/g; return str.replace(re,function ($0,$1){ return $1.toUpperCase(); }); } 数组转字符串 ``` javascript /** param {Array} arr param {String} sp */ function arrToStr(arr,sp){ return arr.jion(sp); } ``` © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-05-04 16:25:25 "},"docs/chapter1/日期.html":{"url":"docs/chapter1/日期.html","title":"日期","keywords":"","body":"日期 yyyy-MM-dd HH-mm-ss转换成yyyy-MM-dd /** * yyyy-MM-dd HH-mm-ss转换成yyyy-MM-dd * @param {String} date - yyyy-MM-dd HH-mm-ss * @returns {String} - yyyy-MM-dd */ function formatDate(date){ if (date) { var date = new Date(date.replace(/-/g, '/')); var myYear = date.getFullYear(); var myMonth = date.getMonth() + 1; var myDate = date.getDate(); myMonth = myMonth 日期格式转换为时间戳 /** * 日期格式转换为时间戳 * @param {String} date - 日期 yyyy-MM-dd HH-mm-ss * @returns {Number} - 时间戳 */ function dateToUnix(date){ if (date) { var date = date.replace(/-/g, '/'); // 将yyy-mm-dd格式装换成yyyy/mm/dd return Date.parse(new Date(date)) / 1000; // parseDate.parse()支持yyyy/mm/dd格式的毫秒数返回 } else{ return null; } } 时间戳转换为日期格式 /** * 时间戳转换为日期格式 * @param {String} unix - 时间戳 * @param {Boolean} needhms - 是否需要HH-mm-ss * @returns {Number} 时间戳 */ function unixToDate(unix, needhms){ if (arguments[1] !== false && !arguments[1]) { needhms = true; } var date = new Date(parseInt(unix) * 1000); var myYear = date.getFullYear(); var myMonth = date.getMonth() + 1; var myDate = date.getDate(); var myHour = date.getHours(); var myMinute = date.getMinutes(); var mySecond = date.getSeconds(); myMonth = myMonth 时间戳拆分 /** * 时间戳拆分 * @param unix - 时间戳 * @returns {Object} year: number, month: number, date: number, hour: number, minute: number, second: number */ function apartDatetime(unix) { var now = new Date(parseInt(unix) * 1000); var year = now.getFullYear(); var month = now.getMonth() + 1; var date = now.getDate(); var hour = now.getHours(); var minute = now.getMinutes(); var second = now.getSeconds(); return { year: year, month: month, date: date, hour: hour, minute: minute, second: second } } © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:10:24 "},"docs/chapter1/DOM操作.html":{"url":"docs/chapter1/DOM操作.html","title":"DOM操作","keywords":"","body":"DOM操作 是否有class /** * @desc 是否有class * @param {Object} obj * @param {String} cls * @returns {Boolean} */ function hasClass(obj, cls) { cls = cls.replace(/^\\s|\\s$/g, \"\") return (\" \" + ((obj || {}).className || \"\").replace(/\\s/g, \" \") + \" \").indexOf(\" \" + cls + \" \") >= 0; } 添加class /** * @desc 添加class * @param {Object} obj * @param {String} cls */ function addClass(obj, cls) { if (!this.hasClass(obj, cls)) obj.className += \" \" + cls; } 删除class /** * @desc 删除class * @param {Object} obj * @param {String} cls */ function removeClass(obj, cls) { cls = cls.replace(/^\\s|\\s$/g, \"\"); if ((\" \" + ((obj || {}).className || \"\").replace(/\\s/g, \" \") + \" \").indexOf(\" \" + cls + \" \") >= 0) { var reg = new RegExp('(\\\\s|^)' + cls + '(\\\\s|$)'); obj.className = obj.className.replace(reg, ' '); } } 获取指定元素的子元素 /** * 获取指定元素的子元素 * @param {object} curEle * @param {string} tagName * @returns {Array} */ function children (curEle, tagName) { var nodeList = curEle.childNodes; var ary = []; if (/MSIE(6|7|8)/.test(navigator.userAgent)) { for (var i = 0; i iframe 父子iframe通信 // 调用父iframe的方法 parent.frames['searchListIframe'].methodName(); // 获取父iframe的dom $(parent.frames[\"filterFrame\"].document).contents()).find(\"selectorName\"); © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:10:24 "},"docs/chapter1/EVENT事件.html":{"url":"docs/chapter1/EVENT事件.html","title":"EVENT事件","keywords":"","body":"EVENT事件 阻止事件冒泡 // 阻止事件冒泡 function stopEventBubble (event) { var e = event || window.event; if (e && e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; } } js实现jquery ready方法 // js实现jquery ready方法 function ready (fn) { if (document.addEventListener) { // 标准浏览器 document.addEventListener('DOMContentLoaded', function () { // 注销时间，避免反复触发 document.removeEventListener('DOMContentLoaded', arguments.callee, false); fn(); // 执行函数 }, false); } else if (document.attachEvent) { // IE浏览器 document.attachEvent('onreadystatechange', function () { if (document.readyState == 'complete') { document.detachEvent('onreadystatechange', arguments.callee); fn(); // 函数执行 } }); } } jQuery – 鼠标经过(hover)事件的延时处理 (function($){ $.fn.hoverDelay = function(options){ var defaults = { hoverDuring: 200, outDuring: 200, hoverEvent: function(){ $.noop(); }, outEvent: function(){ $.noop(); } }; var sets = $.extend(defaults,options || {}); var hoverTimer, outTimer, that = this; return $(this).each(function(){ $(this).hover(function(){ clearTimeout(outTimer); hoverTimer = setTimeout(function(){sets.hoverEvent.apply(that)}, sets.hoverDuring); },function(){ clearTimeout(hoverTimer); outTimer = setTimeout(function(){sets.outEvent.apply(that)}, sets.outDuring); }); }); } })(jQuery); 参数说明： hoverDelay方法共四个参数，表示意思如下： hoverDuring鼠标经过的延时时间 outDuring鼠标移出的延时时间 hoverEvent鼠标经过执行的方法 outEvent鼠标移出执行的方法 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:10:24 "},"docs/chapter1/正则表达式.html":{"url":"docs/chapter1/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式（RegExp） //创建 RegExp 对象的语法：方式1：new RegExp(pattern, attributes);方式2：/pattern/attributes 参数pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。attributes 是一个可选的字符串，包含属性 \"g\"、\"i\" 和 \"m\"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。 //方括号，用于查找某个范围内的字符：表达式 描述[abc] 查找方括号之间的任何字符。[\\^abc] 查找任何不在方括号之间的字符。[0-9] 查找任何从 0 至 9 的数字。[a-z] 查找任何从小写 a 到小写 z 的字符。[A-Z] 查找任何从大写 A 到大写 Z 的字符。[A-z] 查找任何从大写 A 到小写 z 的字符。[adgk] 查找给定集合内的任何字符。[\\^adgk] 查找给定集合外的任何字符。 //元字符，是拥有特殊含义的字符：元字符 描述. 查找单个字符，除了换行和行结束符。\\w 查找单词字符。\\W 查找非单词字符。\\d 查找数字。\\D 查找非数字字符。\\s 查找空白字符。\\S 查找非空白字符。\\b 匹配单词边界。\\B 匹配非单词边界。\\0 查找 NUL 字符。\\n 查找换行符。\\f 查找换页符。\\r 查找回车符。\\t 查找制表符。\\v 查找垂直制表符。\\xxx 查找以八进制数 xxx 规定的字符。\\xdd 查找以十六进制数 dd 规定的字符。\\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 //量词量词 描述n+ 匹配任何包含至少一个 n 的字符串。n* 匹配任何包含零个或多个 n 的字符串。n? 匹配任何包含零个或一个 n 的字符串。n{X} 匹配包含 X 个 n 的序列的字符串。n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。n{X,} 匹配包含至少 X 个 n 的序列的字符串。n$ 匹配任何结尾为 n 的字符串。^n 匹配任何开头为 n 的字符串。?=n 匹配任何其后紧接指定字符串 n 的字符串。?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 //RegExp 对象方法方法 描述compile 编译正则表达式。exec 检索字符串中指定的值。返回找到的值，并确定其位置。test 检索字符串中指定的值。返回 true 或 false。 //支持正则表达式的 String 对象的方法方法 描述 FF IEsearch 检索与正则表达式相匹配的值。match 找到一个或多个正则表达式的匹配。replace 替换与正则表达式匹配的子串。split 把字符串分割为字符串数组。 邮箱 var mail = /\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*/ 手机号正则 var mobile = /^(13|14|15|17|18)\\d{9}$/; 身份证号 var idCard = /^(^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$)|(^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d{4})|\\d{3}[Xx])$)$/ 检测是不是纯数字 var num = /(^-?[0-9]\\d*$)/; 纯中文正则 var cn = /^[\\u4e00-\\u9fa5]+$/; © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-03-05 14:07:32 "},"docs/chapter1/算法-es6版.html":{"url":"docs/chapter1/算法-es6版.html","title":"算法-es6版","keywords":"","body":"算法(es6) js 统计一个字符串出现频率最高的字母/数字 let str = 'asdfghjklaqwertyuiopiaia'; const strChar = str => { let string = [...str], maxValue = '', obj = {}, max = 0; string.forEach(value => { obj[value] = obj[value] == undefined ? 1 : obj[value] + 1 if (obj[value] > max) { max = obj[value] maxValue = value } }) return maxValue; } console.log(strChar(str)) // a 数组去重 forEach let arr = ['1', '2', '3', '1', 'a', 'b', 'b'] const unique = arr => { let obj = {} arr.forEach(value => { obj[value] = 0 }) return Object.keys(obj) } console.log(unique(arr)) // ['1','2','3','a','b'] filter let arr = ['1', '2', '3', '1', 'a', 'b', 'b'] const unique = arr => { return arr.filter((ele, index, array) => { return index === array.indexOf(ele) }) } console.log(unique(arr)) // ['1','2','3','a','b'] set let arr = ['1', '2', '3', '1', 'a', 'b', 'b'] const unique = arr => { return [...new Set(arr)] } console.log(unique(arr)) // ['1','2','3','a','b'] 翻转字符串 let str =\"Hello Dog\"; const reverseString = str =>{ return [...str].reverse().join(\"\"); } console.log(reverseString(str)) // goD olleH 数组中最大差值 forEach let arr = [23, 4, 5, 2, 4, 5, 6, 6, 71, -3]; const difference = arr => { let min = arr[0], max = 0; arr.forEach(value => { if (value max) max = value }) return max - min ; } console.log(difference(arr)) // 74 max、min let arr = [23, 4, 5, 2, 4, 5, 6, 6, 71, -3]; const difference = arr => { let max = Math.max(...arr), min = Math.min(...arr); return max - min ; } console.log(difference(arr)) // 74 不借助临时变量，进行两个整数的交换 数组解构 let a = 2, b = 3; [b,a] = [a,b] console.log(a,b) // 3 2 算术运算（加减） 输入a = 2,b = 3,输出 a = 3,b = 2 let a = 2, b = 3; const swop = (a, b) => { b = b - a; a = a + b; b = a - b; return [a,b]; } console.log(swop(2,3)) // [3,2] 逻辑运算（异或） let a = 2, b = 3; const swop = (a, b) => { a ^= b; //x先存x和y两者的信息 b ^= a; //保持x不变，利用x异或反转y的原始值使其等于x的原始值 a ^= b; //保持y不变，利用x异或反转y的原始值使其等于y的原始值 return [a,b]; } console.log(swop(2,3)) // [3,2] 排序 (从小到大) 冒泡排序let arr = [43, 32, 1, 5, 9, 22]; const sort = arr => { let res = [] arr.forEach((v, i) => { for (let j = i + 1; j arr[j]) { [arr[i],arr[j]] = [arr[j],arr[i]] } } }) return arr } console.log(sort(arr)) // [1, 5, 9, 22, 32, 43] 比较两个数组的内容是否相同 // Warn if overriding existing method if (Array.prototype.equals) console.warn( \"Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.\"); // attach the .equals method to Array's prototype to call it on any array Array.prototype.equals = function (array) { // if the other array is a falsy value, return if (!array) return false; // compare lengths - can save a lot of time if (this.length != array.length) return false; for (var i = 0, l = this.length; i 比较Object Object.prototype.equals = function (object2) { //For the first loop, we only check for types for (propName in this) { //Check for inherited methods and properties - like .equals itself //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty //Return false if the return value is different if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) { return false; } //Check instance type else if (typeof this[propName] != typeof object2[propName]) { //Different types => not equal return false; } } //Now a deeper check using other objects property names for (propName in object2) { //We must check instances anyway, there may be a property that only exists in object2 //I wonder, if remembering the checked values from the first loop would be faster or not if (this.hasOwnProperty(propName) != object2.hasOwnProperty(propName)) { return false; } else if (typeof this[propName] != typeof object2[propName]) { return false; } //If the property is inherited, do not check any more (it must be equa if both objects inherit it) if (!this.hasOwnProperty(propName)) continue; //Now the detail check and recursion //This returns the script back to the array comparing /**REQUIRES Array.equals**/ if (this[propName] instanceof Array && object2[propName] instanceof Array) { // recurse into the nested arrays if (!this[propName].equals(object2[propName])) return false; } else if (this[propName] instanceof Object && object2[propName] instanceof Object) { // recurse into another objects //console.log(\"Recursing to compare \", this[propName],\"with\",object2[propName], \" both named \\\"\"+propName+\"\\\"\"); if (!this[propName].equals(object2[propName])) return false; } //Normal value comparison for strings and numbers else if (this[propName] != object2[propName]) { return false; } } //If everything passed, let's say YES return true; } © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-04-25 16:20:46 "},"docs/chapter2/":{"url":"docs/chapter2/","title":"HTML与CSS","keywords":"","body":"HTML与CSS 此部分主要是HTML与CSS相关的代码，包括一些常用的组件的样式 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:40:53 "},"docs/chapter2/CSS样式.html":{"url":"docs/chapter2/CSS样式.html","title":"CSS样式","keywords":"","body":"css封装 表单 input placeholder ::-webkit-input-placeholder { /* WebKit browsers */ color: #999; } :-moz-placeholder { /* Mozilla Firefox 4 to 18 */ color: #999; } ::-moz-placeholder { /* Mozilla Firefox 19+ */ color: #999; } :-ms-input-placeholder { /* Internet Explorer 10+ */ color: #999; } 文本溢出显示省略号 单行文本 p { overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } 注意事项：如果实现单行文本的溢出显示省略号同学们应该都知道用text-overflow:ellipsis属性来，当然还需要加宽度width属来兼容部分浏览。 多行文本 第1种情况 适用范围：因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； p { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } 注意事项： 1. -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性： 2. display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 3. -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 第2种情况 适用范围：该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。 p { position: relative; line-height: 20px; max-height: 40px; overflow: hidden; } p::after { content: \"...\"; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); } 注意事项： 1. 将height设置为line-height的整数倍，防止超出的文字露出。 2. 给p::after添加渐变背景可避免文字只显示一半。 3. 由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：…）；兼容ie8需要将::after替换成:after。 兼容性 ie8兼容rgba(RR,GG,BB,AA) ie8以上：rgba(RR,GG,BB,AA); ie8：filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#AARRGGBB,endColorstr=#AARRGGBB); vue 隐藏显示的{{}} /*vue*/ [v-cloak] { display: none !important; } 时间轴 时间轴 演示地址：https://musez.github.io/web-dev-tools/pages/timeline.htm html 2018-01-01 00:00:00 武汉佳软信息技术有限公司（以下简称”佳软信息”）成立于2007年，是一家电子政务整体解决方案提供商，位于武汉东湖新技术开发区——“中国光谷”中心的光谷软件园。经过多年的发展，公司的业务范围扩展至政府门户网站建设、行政审批信息化、政府信息资源整合、政府行业管理系统的研发服务，涉及统一门户、统一用户、网站内容管理平台、全文检索、信息资源库、信息资源目录及信息交流平台等，不断为政务服务和民生服务提供优质产品。目前拥有湖北省交通运输厅、省财政厅、省国土资源厅、省公安厅、省质监局、省监察厅等40余家省直部门用户。 2018-01-01 00:00:00 武汉佳软信息技术有限公司（以下简称”佳软信息”） 2018-01-01 00:00:00 武汉佳软信息技术有限公司（以下简称”佳软信息”） scss .timeline { list-style-type: none; padding: 0px; border-left: 2px solid #ccc; margin: 10px 10px 10px 20px; @at-root .timeline_cell { position: relative; margin-top: 15px; padding-left: 20px; b:before { content: ''; position: absolute; left: -10px; width: 18px; height: 18px; border-radius: 9px; background: #ccc; } &.active b:before { background: #359; } .timeline_cell-time, .timeline_cell-desc { display: block; color: #000; a { color: #359; text-decoration: none; } } &.active .timeline_cell-time { color: #359; font-weight: bolder; } } } css .timeline { list-style-type: none; padding: 0px; border-left: 2px solid #ccc; margin: 10px 10px 10px 20px; } .timeline_cell { position: relative; margin-top: 15px; padding-left: 20px; } .timeline_cell b:before { content: ''; position: absolute; left: -10px; width: 18px; height: 18px; border-radius: 9px; background: #ccc; } .timeline_cell.active b:before { background: #359; } .timeline_cell .timeline_cell-time, .timeline_cell .timeline_cell-desc { display: block; color: #000; } .timeline_cell .timeline_cell-time a, .timeline_cell .timeline_cell-desc a { color: #359; text-decoration: none; } .timeline_cell.active .timeline_cell-time { color: #359; font-weight: bolder; } © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-09 14:21:49 "},"docs/chapter2/CSS3动画.html":{"url":"docs/chapter2/CSS3动画.html","title":"CSS3动画","keywords":"","body":"CSS3 常用动画 CSS3 常用四个动画（旋转、放大、旋转放大、移动） 效果一：360°旋转 修改rotate(旋转度数) * { transition:All 0.4s ease-in-out; -webkit-transition:All 0.4s ease-in-out; -moz-transition:All 0.4s ease-in-out; -o-transition:All 0.4s ease-in-out; } *:hover { transform:rotate(360deg); -webkit-transform:rotate(360deg); -moz-transform:rotate(360deg); -o-transform:rotate(360deg); -ms-transform:rotate(360deg); } 效果二：放大 修改scale(放大的值) * { transition:All 0.4s ease-in-out; -webkit-transition:All 0.4s ease-in-out; -moz-transition:All 0.4s ease-in-out; -o-transition:All 0.4s ease-in-out; } *:hover { transform:scale(1.2); -webkit-transform:scale(1.2); -moz-transform:scale(1.2); -o-transform:scale(1.2); -ms-transform:scale(1.2); } 效果三：旋转放大 修改rotate(旋转度数) scale(放大值) * { transition:All 0.4s ease-in-out; -webkit-transition:All 0.4s ease-in-out; -moz-transition:All 0.4s ease-in-out; -o-transition:All 0.4s ease-in-out; } *:hover { transform:rotate(360deg) scale(1.2); -webkit-transform:rotate(360deg) scale(1.2); -moz-transform:rotate(360deg) scale(1.2); -o-transform:rotate(360deg) scale(1.2); -ms-transform:rotate(360deg) scale(1.2); } 效果四：上下左右移动 修改translate(x轴,y轴) * { transition:All 0.4s ease-in-out; -webkit-transition:All 0.4s ease-in-out; -moz-transition:All 0.4s ease-in-out; -o-transition:All 0.4s ease-in-out; } *:hover { transform:translate(0,-10px); -webkit-transform:translate(0,-10px); -moz-transform:translate(0,-10px); -o-transform:translate(0,-10px); -ms-transform:translate(0,-10px); } SCSS改造 // 执行动画以及执行时间设定 @mixin dz($time:0.25s){ -webkit-transition: all $time ease-in-out; -moz-transition: all $time ease-in-out; -o-transition: all $time ease-in-out; -ms-transition: all $time ease-in-out; transition: all $time ease-in-out; } // 宣传动画调用 @mixin xz($deg:360){ transform:rotate($deg+deg); -webkit-transform:rotate($deg+deg); -moz-transform:rotate($deg+deg); -o-transform:rotate($deg+deg); -ms-transform:rotate($deg+deg); } // 放大动画 @minxin fd($s1:1.2){ transform:scale($s1); -webkit-transform:scale($s1); -moz-transform:scale($s1); -o-transform:scale($s1); -ms-transform:scale($s1); } // 旋转放大动画 @mixin xzfd($deg:360,$s1:1.2){ transform:rotate($deg+deg) scale($s1); -webkit-transform:rotate($deg+deg) scale($s1); -moz-transform:rotate($deg+deg) scale($s1); -o-transform:rotate($deg+deg) scale($s1); -ms-transform:rotate($deg+deg) scale($s1); } // 移动动画 @mixin yd($s1:0,$s2:0){ transform:translate($s1,$s2); -webkit-transform:translate($s1,$s2); -moz-transform:translate($s1,$s2); -o-transform:translate($s1,$s2); -ms-transform:translate($s1,$s2); } 使用方法 #somebox{ @include dz(); &:hover { @include yd(-10px,-10px); } } © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-08 10:10:24 "},"docs/chapter2/CSS设置居中的方案.html":{"url":"docs/chapter2/CSS设置居中的方案.html","title":"CSS设置居中的方案","keywords":"","body":"CSS设置居中的方案 块级元素居中 html代码部分 child 行内元素居中 html代码部分 child 水平居中 行内元素 text-align: center; .parent { text-align: center; } 块级元素 margin: auto; （低版本浏览器还需要设置 text-align: center;） .parent { text-align: center; } .child { margin: auto; } 垂直居中 行内元素（单行文字垂直居中） .parent { height: 200px; line-height: 200px; } 块级元素：绝对定位（需要提前知道尺寸） 优点：兼容性不错 缺点：需要提前知道尺寸 .parent { position: relative; height: 200px; } .child { width: 80px; height: 40px; background: blue; position: absolute; left: 50%; top: 50%; margin-top: -20px; margin-left: -40px; } © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-09 14:21:49 "},"docs/chapter4/":{"url":"docs/chapter4/","title":"开发工具","keywords":"","body":"开发工具 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-10 20:39:41 "},"docs/chapter4/开发者工具.html":{"url":"docs/chapter4/开发者工具.html","title":"开发者工具","keywords":"","body":"开发者工具 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-02-23 09:24:18 "},"docs/chapter5/":{"url":"docs/chapter5/","title":"markdown语法","keywords":"","body":"markdown的常用语法 简介 Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。 注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！ markdown的常用语法 标题 Markdown 标题支持两种形式： 用#标记在标题开头加上1~6个#，依次代表一级标题、二级标题....六级标题 用=和-标记在标题底下加上任意个=代表一级标题，-代表二级标题 列表 有序列表 数字不能省略但可无序，点号之后的空格不能少。建立多级列表时，每个子级别都要比上个级别前面多打2个以上空格。 1. Item-1 1.1. Item-1-1 1.1.1. Item-1-1-1 1.1.1.1. Item-1-1-1-1 1.2. Item-1-2 2. Item-2 3. Item-3 Item-1 1.1. Item-1-1 1.1.1. Item-1-1-1 1.1.1.1. Item-1-1-1-1 1.2. Item-1-2 Item-2 Item-3 无序列表 符号之后的空格不能少，-、+、*效果一样，在嵌套列表中可以循环使用。 - Item-1 - Item-1-1 + Item-1-1-1 * Item-1-1-1-1 * Item-1-2 + Item-2 * Item-3 Item-1 Item-1-1 Item-1-1-1 Item-1-1-1-1 Item-1-2 Item-2 Item-3 注：列表项里面可能包含多个段落，后面的段落必须用4个空格或1个制表符缩进。 - Item-1 - Item-1-1 Item-1-1 (continued...) Item-1-1 (continued...) - Item-1-2 - Item-2 Item-1 Item-1-1 Item-1-1 (continued...) Item-1-1 (continued...) Item-1-2 Item-2 注释 [comment]: <> (这里是注释) [//]: <> (这里是注释) [//]: # (这里是注释) [^_^]: 这里是注释 © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-05-03 10:59:48 "},"docs/":{"url":"docs/","title":"版本记录","keywords":"","body":"版本记录 2018-05-03 更新日志 A 新增 版本记录 U © WangYue 2018 all right reserved，powered by Gitbook修订时间： 2018-05-03 10:48:31 "}}